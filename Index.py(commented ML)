import pandas as pd
from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
import random
from itertools import combinations
import math
import os
from collections import defaultdict
from datetime import datetime, timedelta
import requests
import json
import numpy as np
import traceback
import warnings

# --- COMMENTED OUT ML/DL IMPORTS & WARNINGS ---
# from sklearn.cluster import KMeans
# from sklearn.preprocessing import StandardScaler
# from sklearn.decomposition import PCA
# import tensorflow as tf
# from tensorflow.keras.models import Model
# from tensorflow.keras.layers import Input, Dense, Lambda
# from tensorflow.keras import backend as K
warnings.filterwarnings('ignore', category=UserWarning, module='sklearn') # Ignore specific KMeans warning

# --- Supabase Configuration ---
SUPABASE_PROJECT_URL = os.environ.get("SUPABASE_URL", "https://yksxzbbcoitehdmsxqex.supabase.co")
SUPABASE_ANON_KEY = os.environ.get("SUPABASE_ANON_KEY", "YOUR_ACTUAL_SUPABASE_ANON_KEY_GOES_HERE")
SUPABASE_SERVICE_KEY = os.environ.get("SUPABASE_SERVICE_KEY", "YOUR_ACTUAL_SUPABASE_SERVICE_ROLE_KEY_GOES_HERE")

SUPABASE_TABLE_NAME = 'powerball_draws'
GENERATED_NUMBERS_TABLE_NAME = 'generated_powerball_numbers'

# --- Flask App Initialization with Template Path ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
TEMPLATE_DIR = os.path.join(BASE_DIR, '..', 'templates')

app = Flask(__name__, template_folder=TEMPLATE_DIR)
app.secret_key = 'supersecretkey'

# --- Global Data and Cache ---
df = pd.DataFrame()
last_draw = pd.Series(dtype='object')

historical_white_ball_sets = set()
white_ball_co_occurrence_lookup = {}

analysis_cache = {}
last_analysis_cache_update = datetime.min

CACHE_DURATION = timedelta(minutes=60) # Cache for 60 minutes
CACHE_EXPIRATION_SECONDS = CACHE_DURATION.total_seconds()

# --- COMMENTED OUT ML/DL GLOBAL VARIABLES ---
# kmeans_model = None
# scaler_model = None
# clustering_features_columns = [] # To store the names of features for clarity
# NEW Global Variables for VAE-like model
# feature_means = None
# feature_stds = None
# feature_min_max = None # To store min/max for each feature for clamping
# vae_features_columns = [] # Renamed from clustering_features_columns for clarit

group_a = [3, 5, 6, 7, 9, 11, 15, 16, 18, 21, 23, 24, 27, 31, 32, 33, 36, 42, 44, 45, 48, 50, 51, 54, 55, 60, 66, 69]
GLOBAL_WHITE_BALL_RANGE = (1, 69)
GLOBAL_POWERBALL_RANGE = (1, 26)

NUMBER_RANGES = {
    "1-9": (1, 9),
    "10s": (10, 19),
    "20s": (20, 29),
    "30s": (30, 39),
    "40s": (40, 49),
    "50s": (50, 59),
    "60s": (60, 69)
}

ASCENDING_GEN_RANGES = [
    (10, 19),
    (20, 29),
    (30, 39),
    (40, 49),
    (50, 59),
    (60, 69)
]

SUM_RANGES = {
    "Any": None,
    "Zone A (60-99)": (60, 99),
    "Zone B (100-129)": (100, 129),
    "Zone C (130-159)": (130, 159),
    "Zone D (160-189)": (160, 189),
    "Zone E (190-220)": (190, 220),
    "Zone F (221-249)": (221, 249),
    "Zone G (250-300)": (250, 300)
}

LOW_NUMBER_MAX = 34
HIGH_NUMBER_MIN = 35

POWERBALL_DRAW_DAYS = ['Monday', 'Wednesday', 'Saturday']

BOUNDARY_PAIRS_TO_ANALYZE = [
    (9, 10), (19, 20), (29, 30), (39, 40), (49, 50), (59, 60)
]

# NEW: Define the types of range-based patterns observed by the user
RANGE_PATTERN_TYPES = [
    "Single Pick (1-1-1-1-1)",
    "Two-Number Pick (2-1-1-1)",
    "Three-Number Pick (3-1-1)",
    "Two-Two-Number Pick (2-2-1)",
    "One-Two-Three Number Pick (1-2-3)"
]

# NEW Global Variable for recent odd/even ratios
recent_odd_even_ratios = [] # To store the last few odd/even splits

# ... (after NUMBER_RANGES definition) ...

def _get_ball_ranges_counts(white_balls):
    """
    Counts how many white balls fall into each predefined NUMBER_RANGES decade.
    Returns a dictionary like {'1-9': 2, '10s': 1, '20s': 0, ...}
    """
    range_counts = defaultdict(int)
    for num in white_balls:
        for range_name, (min_val, max_val) in NUMBER_RANGES.items():
            if min_val <= num <= max_val:
                range_counts[range_name] += 1
                break
    return range_counts

# ... (after _get_ball_ranges_counts function) ...

def _classify_range_pattern(white_balls):
    """
    Classifies the pattern of white balls based on their distribution across predefined ranges.
    Patterns include "Single Pick", "Two-Number Pick", "Three-Number Pick", "Two-Two-Number Pick".

    Args:
        white_balls (list): A sorted list of 5 white ball numbers.

    Returns:
        str: The classification of the pattern (e.g., "Single Pick (1-1-1-1-1)", "Two-Number Pick (2-1-1-1)", "Other").
    """
    range_counts = _get_ball_ranges_counts(white_balls)

    # Get counts of how many numbers fall into each range, ignoring ranges with 0 balls
    active_range_ball_counts = sorted([count for count in range_counts.values() if count > 0], reverse=True)

    if not active_range_ball_counts: # Should not happen with 5 balls, but as a safeguard
        return "Other"

    # Pattern: Single Pick (1-1-1-1-1) - each ball from a different range
    # This means there are 5 active ranges, each with 1 ball
    if active_range_ball_counts == [1, 1, 1, 1, 1]:
        return "Single Pick (1-1-1-1-1)"

    # Pattern: Two-Number Pick (2-1-1-1) - two balls from one range, one from three others
    if active_range_ball_counts == [2, 1, 1, 1]:
        return "Two-Number Pick (2-1-1-1)"

    # Pattern: Three-Number Pick (3-1-1) - three balls from one range, one from two others
    if active_range_ball_counts == [3, 1, 1]:
        return "Three-Number Pick (3-1-1)"

    # Pattern: Two-Two-Number Pick (2-2-1) - two from one range, two from another, one from a third
    if active_range_ball_counts == [2, 2, 1]:
        return "Two-Two-Number Pick (2-2-1)"

   # Pattern: One-Two-Three Number Pick (1-2-3) - one from one range, two from another, three from a third
    if active_range_ball_counts == [3, 2, 1]:
        return "One-Two-Three Number Pick (1-2-3)"

    # Other patterns not explicitly defined by user's observation (e.g., 4-1, 5-0, or other combinations)
    return "Other"

# --- Gemini API Configuration ---
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "")


# --- Core Utility Functions ---

def _get_supabase_headers(is_service_key=False):
    key = SUPABASE_SERVICE_KEY if is_service_key else SUPABASE_ANON_KEY
    return {
        "apikey": key,
        "Authorization": f"Bearer {key}",
        "Content-Type": "application/json"
    }

def load_historical_data_from_supabase():
    """Fetches historical Powerball draw data from Supabase."""
    all_data = []
    offset = 0
    limit = 1000

    try:
        url = f"{SUPABASE_PROJECT_URL}/rest/v1/{SUPABASE_TABLE_NAME}"
        headers = _get_supabase_headers(is_service_key=False)

        while True:
            params = {
                'select': '*',
                'order': 'Draw Date.asc',
                'offset': offset,
                'limit': limit
            }
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()

            chunk = response.json()
            if not chunk:
                break
            all_data.extend(chunk)
            offset += limit

        if not all_data:
            print("No data fetched from Supabase after pagination attempts.")
            return pd.DataFrame()

        df_loaded = pd.DataFrame(all_data)
        df_loaded['Draw Date_dt'] = pd.to_datetime(df_loaded['Draw Date'], errors='coerce')
        df_loaded = df_loaded.dropna(subset=['Draw Date_dt'])

        numeric_cols = ['Number 1', 'Number 2', 'Number 3', 'Number 4', 'Number 5', 'Powerball']
        for col in numeric_cols:
            if col in df_loaded.columns:
                df_loaded[col] = pd.to_numeric(df_loaded[col], errors='coerce')
                df_loaded[col] = df_loaded[col].fillna(0).astype(int)
            else:
                print(f"Warning: Column '{col}' not found in fetched data. Skipping conversion for this column.")

        df_loaded['Draw Date'] = df_loaded['Draw Date_dt'].dt.strftime('%Y-%m-%d')

        print(f"Successfully loaded and processed {len(df_loaded)} records from Supabase.")
        return df_loaded

    except requests.exceptions.RequestException as e:
        print(f"Error during Supabase data fetch request: {e}")
        if hasattr(e, 'response') and e.response is not None:
            print(f"Supabase response content: {e.response.text}")
        return pd.DataFrame()
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON response from Supabase: {e}")
        if 'response' in locals() and response is not None:
            print(f"Response content that failed JSON decode: {response.text}")
        return pd.DataFrame()
    except Exception as e:
        print(f"An unexpected error occurred in load_historical_data_from_supabase: {e}")
        return pd.DataFrame()

def get_last_draw(df_source):
    """Retrieves the most recent draw from the DataFrame."""
    if df_source.empty:
        return pd.Series({
            'Draw Date': 'N/A', 'Number 1': 'N/A', 'Number 2': 'N/A',
            'Number 3': 'N/A', 'Number 4': 'N/A', 'Number 5': 'N/A', 'Powerball': 'N/A',
            'Numbers': ['N/A', 'N/A', 'N/A', 'N/A', 'N/A']
        }, dtype='object')

    last_row = df_source.iloc[-1].copy()

    if 'Number 1' in last_row and pd.notna(last_row['Number 1']):
        last_row['Numbers'] = [
            int(last_row['Number 1']), int(last_row['Number 2']), int(last_row['Number 3']),
            int(last_row['Number 4']), int(last_row['Number 5'])
        ]
    else:
        last_row['Numbers'] = ['N/A'] * 5

    if 'Draw Date_dt' in last_row and pd.notna(last_row['Draw Date_dt']):
        last_row['Draw Date'] = last_row['Draw Date_dt'].strftime('%Y-%m-%d')
    elif 'Draw Date' not in last_row:
        last_row['Draw Date'] = 'N/A'

    return last_row

def check_exact_match(white_balls):
    """Checks if a given set of white balls exactly matches any historical draw."""
    global historical_white_ball_sets
    return frozenset(white_balls) in historical_white_ball_sets

def generate_powerball_numbers(df_source, group_a_list, odd_even_choice, combo_choice, white_ball_range, powerball_range, excluded_numbers, high_low_balance=None, selected_sum_range_tuple=None, is_simulation=False):
    """Generates a single Powerball combination based on various criteria."""
    if df_source.empty:
        raise ValueError("Cannot generate numbers: Historical data is empty.")

    max_attempts = 5000
    attempts = 0

    base_available_white_balls = [num for num in range(white_ball_range[0], white_ball_range[1] + 1) if num not in excluded_numbers]
    if len(base_available_white_balls) < 5:
        raise ValueError("Not enough available white balls after exclusions and range constraints.")

    while attempts < max_attempts:

        white_balls_candidate = sorted(random.sample(base_available_white_balls, 5))

        even_count = sum(1 for num in white_balls_candidate if num % 2 == 0)
        odd_count = 5 - even_count

        if odd_even_choice == "All Even" and even_count != 5:
            attempts += 1
            continue
        elif odd_even_choice == "All Odd" and odd_count != 5:
            attempts += 1
            continue
        elif odd_even_choice == "3 Even / 2 Odd" and (even_count != 3 or odd_count != 2):
            attempts += 1
            continue
        elif odd_even_choice == "2 Even / 3 Odd" and (even_count != 2 or odd_count != 3):
            attempts += 1
            continue
        elif odd_even_choice == "1 Even / 4 Odd" and (even_count != 1 or odd_count != 4):
            attempts += 1
            continue
        elif odd_even_choice == "4 Even / 1 Odd" and (even_count != 4 or odd_count != 1):
            attempts += 1
            continue

        if selected_sum_range_tuple:
            current_sum = sum(white_balls_candidate)
            if not (selected_sum_range_tuple[0] <= current_sum <= selected_sum_range_tuple[1]):
                attempts += 1
                continue

        group_a_numbers = [num for num in white_balls_candidate if num in group_a_list]
        if len(group_a_numbers) < 2:
            attempts += 1
            continue

        if high_low_balance is not None:
            low_numbers_count = sum(1 for num in white_balls_candidate if num <= LOW_NUMBER_MAX)
            high_numbers_count = sum(1 for num in white_balls_candidate if num >= HIGH_NUMBER_MIN)
            if low_numbers_count != high_low_balance[0] or high_numbers_count != high_low_balance[1]:
                attempts += 1
                continue

        if not is_simulation:
            last_draw_data = get_last_draw(df_source)
            if not last_draw_data.empty and last_draw_data.get('Draw Date') != 'N/A':
                last_white_balls = [int(last_draw_data['Number 1']), int(last_draw_data['Number 2']), int(last_draw_data['Number 3']), int(last_draw_data['Number 4']), int(last_draw_data['Number 5'])]
                if set(white_balls_candidate) == set(last_white_balls):
                    attempts += 1
                    continue

            if check_exact_match(white_balls_candidate):
                attempts += 1
                continue

        powerball = random.randint(powerball_range[0], powerball_range[1])
        return white_balls_candidate, powerball

    raise ValueError("Could not generate a unique combination meeting all criteria after many attempts. Try adjusting filters or increasing max_attempts.")


def generate_from_group_a(df_source, num_from_group_a, white_ball_range, powerball_range, excluded_numbers, selected_sum_range_tuple=None):
    """Generates a Powerball combination ensuring a certain number of Group A numbers."""
    if df_source.empty:
        raise ValueError("Cannot generate numbers: Historical data is empty.")

    max_attempts = 2000
    attempts = 0

    valid_group_a = [num for num in group_a if white_ball_range[0] <= num <= white_ball_range[1] and num not in excluded_numbers]

    remaining_pool = [num for num in range(white_ball_range[0], white_ball_range[1] + 1)
                      if num not in valid_group_a and num not in excluded_numbers]

    if len(valid_group_a) < num_from_group_a:
        raise ValueError(f"Not enough unique numbers in Group A ({len(valid_group_a)}) to pick {num_from_group_a}.")

    num_from_remaining = 5 - num_from_group_a
    if len(remaining_pool) < num_from_remaining:
        raise ValueError(f"Not enough unique numbers in the remaining pool ({len(remaining_pool)}) to pick {num_from_remaining}.")

    while attempts < max_attempts:
        try:
            selected_from_group_a = random.sample(valid_group_a, num_from_group_a)

            available_for_remaining = [num for num in remaining_pool if num not in selected_from_group_a]
            if len(available_for_remaining) < num_from_remaining:
                attempts += 1
                continue
            selected_from_remaining = random.sample(available_for_remaining, num_from_remaining)
            white_balls = sorted(selected_from_group_a + selected_from_remaining)
            if selected_sum_range_tuple:
                current_sum = sum(white_balls)
                if not (selected_sum_range_tuple[0] <= current_sum <= selected_sum_range_tuple[1]):
                    attempts += 1
                    continue
            powerball = random.randint(powerball_range[0], powerball_range[1])
            if check_exact_match(white_balls):
                attempts += 1
                continue
            break
        except ValueError as e:
            attempts += 1
            continue
        except IndexError:
            attempts += 1
            continue
    else:
        raise ValueError("Could not generate a unique combination with Group A strategy meeting all criteria after many attempts. Try adjusting filters.")
    return white_balls, powerball

def generate_with_user_provided_pair(num1, num2, white_ball_range, powerball_range, excluded_numbers, df_source, selected_sum_range_tuple=None):
    """Generates a Powerball combination starting with two user-provided white balls."""
    if df_source.empty:
        raise ValueError("Cannot generate with provided pair: Historical data is empty.")

    if not (white_ball_range[0] <= num1 <= white_ball_range[1] and
            white_ball_range[0] <= num2 <= white_ball_range[1]):
        raise ValueError(f"Provided numbers ({num1}, {num2}) must be within the white ball range ({white_ball_range[0]}-{white_ball_range[1]}).")

    if num1 == num2:
        raise ValueError("The two provided white balls must be unique.")

    if num1 in excluded_numbers or num2 in excluded_numbers:
        raise ValueError(f"One or both provided numbers ({num1}, {num2}) are in the excluded list.")

    initial_white_balls = sorted([num1, num2])

    max_attempts_overall = 2000
    attempts_overall = 0

    while attempts_overall < max_attempts_overall:
        candidate_white_balls_generated = []
        temp_current_min = initial_white_balls[-1] + 1

        try:
            for i in range(3):
                possible_nums_for_slot = []

                start_range_idx = -1
                for idx, (range_min, range_max) in enumerate(ASCENDING_GEN_RANGES):
                    if temp_current_min <= range_max and temp_current_min >= range_min:
                        start_range_idx = idx
                        break
                    elif temp_current_min < range_min:
                        start_range_idx = idx
                        break

                if start_range_idx == -1:
                    raise ValueError("Not enough space in ascending ranges to complete combination.")

                eligible_ranges = ASCENDING_GEN_RANGES[start_range_idx:]

                for range_min, range_max in eligible_ranges:
                    actual_start_val = max(temp_current_min, range_min)

                    for num in range(actual_start_val, range_max + 1):
                        if num not in excluded_numbers and \
                           num not in initial_white_balls and \
                           num not in candidate_white_balls_generated:
                            possible_nums_for_slot.append(num)

                if not possible_nums_for_slot:
                    raise ValueError(f"No available numbers for slot {i+3}. Current min: {temp_current_min}, initial: {initial_white_balls}, generated: {candidate_white_balls_generated}")

                picked_num = random.choice(possible_nums_for_slot)
                candidate_white_balls_generated.append(picked_num)
                temp_current_min = picked_num + 1

            final_white_balls = sorted(initial_white_balls + candidate_white_balls_generated)

            if selected_sum_range_tuple:
                current_sum = sum(final_white_balls)
                if not (selected_sum_range_tuple[0] <= current_sum <= selected_sum_range_tuple[1]):
                    attempts_overall += 1
                    continue

            powerball = random.randint(powerball_range[0], powerball_range[1])

            if check_exact_match(final_white_balls):
                attempts_overall += 1
                continue

            last_draw_data = get_last_draw(df_source)
            if not last_draw_data.empty and last_draw_data.get('Draw Date') != 'N/A':
                last_white_balls = [int(last_draw_data['Number 1']), int(last_draw_data['Number 2']), int(last_draw_data['Number 3']), int(last_draw_data['Number 4']), int(last_draw_data['Number 5'])]
                if set(final_white_balls) == set(last_white_balls) and powerball == int(last_draw_data['Powerball']):
                    attempts_overall += 1
                    continue

            return final_white_balls, powerball

        except ValueError as e:
            attempts_overall += 1
            continue
        except IndexError:
            attempts_overall += 1
            continue
    else:
        raise ValueError("Could not generate a unique combination with the provided pair and ascending range constraint meeting all criteria after many attempts. Try adjusting filters.")


# --- COMMENTED OUT ML/DL FUNCTIONS ---
# def _extract_features_for_draw(draw_row):
#     """
#     Extracts a numerical feature vector from a single Powerball draw row.
#     This vector will be used for generative model training.
#     """
#     if pd.isna(draw_row['Number 1']): # Ensure draw data is valid
#         return None
#
#     white_balls = sorted([
#         int(draw_row['Number 1']), int(draw_row['Number 2']), int(draw_row['Number 3']),
#         int(draw_row['Number 4']), int(draw_row['Number 5'])
#     ])
#     powerball = int(draw_row['Powerball'])
#
#     odd_count = sum(1 for num in white_balls if num % 2 != 0)
#     even_count = 5 - odd_count
#     white_ball_sum = sum(white_balls)
#     group_a_count = sum(1 for num in white_balls if num in group_a)
#
#     consecutive_pairs_count = 0
#     for i in range(len(white_balls) - 1):
#         if white_balls[i] + 1 == white_balls[i+1]:
#             consecutive_pairs_count += 1
#
#     tens_apart_pairs_count = 0
#     for i in range(len(white_balls)):
#         for j in range(i + 1, len(white_balls)):
#             diff = abs(white_balls[i] - white_balls[j])
#             if diff in [10, 20, 30, 40, 50]:
#                 tens_apart_pairs_count += 1
#
#     last_digit_counts = defaultdict(int)
#     for num in white_balls:
#         last_digit_counts[num % 10] += 1
#     same_last_digit_count = sum(count for count in last_digit_counts.values() if count >= 2)
#
#     repeating_digit_numbers = [11, 22, 33, 44, 55, 66]
#     repeating_digit_count = sum(1 for num in white_balls if num in repeating_digit_numbers)
#
#     num_in_range = defaultdict(int)
#     for num in white_balls:
#         if 1 <= num <= 9: num_in_range['1-9'] += 1
#         elif 10 <= num <= 19: num_in_range['10s'] += 1
#         elif 20 <= num <= 29: num_in_range['20s'] += 1
#         elif 30 <= num <= 39: num_in_range['30s'] += 1
#         elif 40 <= num <= 49: num_in_range['40s'] += 1
#         elif 50 <= num <= 59: num_in_range['50s'] += 1
#         elif 60 <= num <= 69: num_in_range['60s'] += 1
#
#     draw_weekday = draw_row['Draw Date_dt'].day_name()
#     is_monday_draw = 1 if draw_weekday == 'Monday' else 0
#     is_wednesday_draw = 1 if draw_weekday == 'Wednesday' else 0
#     is_saturday_draw = 1 if draw_weekday == 'Saturday' else 0
#
#     powerball_value = powerball
#
#     # NEW: Classify and one-hot encode the range pattern
#     current_range_pattern_type = _classify_range_pattern(white_balls)
#     is_single_pick_pattern = 1 if current_range_pattern_type == "Single Pick (1-1-1-1-1)" else 0
#     is_two_number_pick_pattern = 1 if current_range_pattern_type == "Two-Number Pick (2-1-1-1)" else 0
#     is_three_number_pick_pattern = 1 if current_range_pattern_type == "Three-Number Pick (3-1-1)" else 0
#     is_two_two_pick_pattern = 1 if current_range_pattern_type == "Two-Two-Number Pick (2-2-1)" else 0
#     is_one_two_three_pick_pattern = 1 if current_range_pattern_type == "One-Two-Three Number Pick (1-2-3)" else 0
#
#     features = [
#         odd_count, even_count, white_ball_sum, group_a_count, consecutive_pairs_count,
#         tens_apart_pairs_count, same_last_digit_count, repeating_digit_count,
#         num_in_range['1-9'], num_in_range['10s'], num_in_range['20s'],
#         num_in_range['30s'], num_in_range['40s'], num_in_range['50s'], num_in_range['60s'],
#         is_monday_draw, is_wednesday_draw, is_saturday_draw, powerball_value,
#         is_single_pick_pattern, is_two_number_pick_pattern, is_three_number_pick_pattern, is_two_two_pick_pattern
#     ]
#     return features
#
#
# def _extract_features_for_candidate(white_balls, powerball, draw_date_dt):
#     """
#     Extracts a numerical feature vector from a candidate Powerball pick
#     (list of white balls, powerball, and a datetime object for the draw date).
#     Used for evaluating candidate picks against cluster centroids.
#     """
#     if not isinstance(white_balls, list) or len(white_balls) != 5:
#         return None
#     if not isinstance(powerball, int) or not (GLOBAL_POWERBALL_RANGE[0] <= powerball <= GLOBAL_POWERBALL_RANGE[1]):
#         return None
#     if not isinstance(draw_date_dt, datetime):
#         draw_date_dt = datetime.now()
#
#     if not all(GLOBAL_WHITE_BALL_RANGE[0] <= num <= GLOBAL_WHITE_BALL_RANGE[1] for num in white_balls):
#         return None
#     if len(set(white_balls)) != 5:
#         return None
#
#     sorted_white_balls = sorted(white_balls)
#
#     odd_count = sum(1 for num in sorted_white_balls if num % 2 != 0)
#     even_count = 5 - odd_count
#     white_ball_sum = sum(sorted_white_balls)
#     group_a_count = sum(1 for num in sorted_white_balls if num in group_a)
#
#     consecutive_pairs_count = 0
#     for i in range(len(sorted_white_balls) - 1):
#         if sorted_white_balls[i] + 1 == sorted_white_balls[i+1]:
#             consecutive_pairs_count += 1
#
#     tens_apart_pairs_count = 0
#     for i in range(len(sorted_white_balls)):
#         for j in range(i + 1, len(sorted_white_balls)):
#             diff = abs(sorted_white_balls[i] - sorted_white_balls[j])
#             if diff in [10, 20, 30, 40, 50]:
#                 tens_apart_pairs_count += 1
#
#     last_digit_counts = defaultdict(int)
#     for num in sorted_white_balls:
#         last_digit_counts[num % 10] += 1
#     same_last_digit_count = sum(count for count in last_digit_counts.values() if count >= 2)
#
#     repeating_digit_numbers = [11, 22, 33, 44, 55, 66]
#     repeating_digit_count = sum(1 for num in sorted_white_balls if num in repeating_digit_numbers)
#
#     num_in_range = defaultdict(int)
#     for num in sorted_white_balls:
#         if 1 <= num <= 9: num_in_range['1-9'] += 1
#         elif 10 <= num <= 19: num_in_range['10s'] += 1
#         elif 20 <= num <= 29: num_in_range['20s'] += 1
#         elif 30 <= num <= 39: num_in_range['30s'] += 1
#         elif 40 <= num <= 49: num_in_range['40s'] += 1
#         elif 50 <= num <= 59: num_in_range['50s'] += 1
#         elif 60 <= num <= 69: num_in_range['60s'] += 1
#
#     draw_weekday = draw_date_dt.day_name()
#     is_monday_draw = 1 if draw_weekday == 'Monday' else 0
#     is_wednesday_draw = 1 if draw_weekday == 'Wednesday' else 0
#     is_saturday_draw = 1 if draw_weekday == 'Saturday' else 0
#
#     powerball_value = powerball
#
#     # NEW: Classify and one-hot encode the range pattern
#     current_range_pattern_type = _classify_range_pattern(white_balls)
#     is_single_pick_pattern = 1 if current_range_pattern_type == "Single Pick (1-1-1-1-1)" else 0
#     is_two_number_pick_pattern = 1 if current_range_pattern_type == "Two-Number Pick (2-1-1-1)" else 0
#     is_three_number_pick_pattern = 1 if current_range_pattern_type == "Three-Number Pick (3-1-1)" else 0
#     is_two_two_pick_pattern = 1 if current_range_pattern_type == "Two-Two-Number Pick (2-2-1)" else 0
#     is_one_two_three_pick_pattern = 1 if current_range_pattern_type == "One-Two-Three Number Pick (1-2-3)" else 0
#
#     features = [
#         odd_count, even_count, white_ball_sum, group_a_count, consecutive_pairs_count,
#         tens_apart_pairs_count, same_last_digit_count, repeating_digit_count,
#         num_in_range['1-9'], num_in_range['10s'], num_in_range['20s'],
#         num_in_range['30s'], num_in_range['40s'], num_in_range['50s'], num_in_range['60s'],
#         is_monday_draw, is_wednesday_draw, is_saturday_draw, powerball_value,
#         is_single_pick_pattern, is_two_number_pick_pattern, is_three_number_pick_pattern, is_two_two_pick_pattern
#     ]
#     return features
#
# def _generate_pick_for_cluster(target_cluster_centroid, current_draw_date_dt, excluded_numbers, max_attempts_per_pick=2000):
#     """
#     Generates a single Powerball pick (5 white balls + 1 powerball) that closely
#     matches the given target_cluster_centroid based on features.
#     """
#     global kmeans_model, scaler_model, df, historical_white_ball_sets
#
#     if kmeans_model is None or scaler_model is None:
#         print("Clustering model or scaler not trained. Cannot generate ML picks.")
#         return None, None
#
#     best_pick_white_balls = None
#     best_pick_powerball = None
#     min_distance = float('inf')
#
#     available_white_balls_pool = [num for num in range(GLOBAL_WHITE_BALL_RANGE[0], GLOBAL_WHITE_BALL_RANGE[1] + 1)
#                                   if num not in excluded_numbers]
#
#     if len(available_white_balls_pool) < 5:
#         print(f"Not enough white balls in pool ({len(available_white_balls_pool)}) after exclusions for ML pick generation.")
#         return None, None
#
#     # Consider the last few draws to avoid immediately repeating the most recent history
#     last_5_white_ball_sets = []
#     if not df.empty:
#         for _, row in df.tail(5).iterrows():
#             last_5_white_ball_sets.append(frozenset([
#                 int(row['Number 1']), int(row['Number 2']), int(row['Number 3']),
#                 int(row['Number 4']), int(row['Number 5'])
#             ]))
#
#     for attempt in range(max_attempts_per_pick):
#         try:
#             candidate_white_balls = sorted(random.sample(available_white_balls_pool, 5))
#             candidate_powerball = random.randint(GLOBAL_POWERBALL_RANGE[0], GLOBAL_POWERBALL_RANGE[1])
#
#             # Skip if exact historical match (or very recent match)
#             if frozenset(candidate_white_balls) in historical_white_ball_sets:
#                 continue
#             if frozenset(candidate_white_balls) in last_5_white_ball_sets:
#                 continue
#
#             # Calculate features for the candidate pick
#             candidate_features = _extract_features_for_candidate(
#                 candidate_white_balls, candidate_powerball, current_draw_date_dt
#             )
#
#             if candidate_features is None: # Should not happen if previous checks pass, but good safeguard
#                 continue
#
#             # Scale the candidate features using the *trained* scaler
#             scaled_candidate_features = scaler_model.transform(np.array(candidate_features).reshape(1, -1))[0]
#
#             # Calculate Euclidean distance to the target cluster centroid
#             distance = np.linalg.norm(scaled_candidate_features - target_cluster_centroid)
#
#             if distance < min_distance:
#                 min_distance = distance
#                 best_pick_white_balls = candidate_white_balls
#                 best_pick_powerball = candidate_powerball
#
#                 # Early exit if a very good match is found
#                 if min_distance < 0.1: # Threshold can be tuned
#                     break
#
#         except ValueError: # e.g., random.sample pool too small after exclusions
#             continue
#         except IndexError: # e.g. if _extract_features_for_candidate returns None unexpectedly
#             continue
#         except Exception as e:
#             # print(f"Error during ML pick generation attempt {attempt}: {e}")
#             continue
#
#     return best_pick_white_balls, best_pick_powerball
#
#
# # --- VAE-like Model Functions ---
#
# def _build_vae_model(input_dim, latent_dim=2):
#     # VAE encoder
#     encoder_inputs = Input(shape=(input_dim,))
#     x = Dense(16, activation='relu')(encoder_inputs)
#     x = Dense(8, activation='relu')(x)
#     z_mean = Dense(latent_dim, name='z_mean')(x)
#     z_log_var = Dense(latent_dim, name='z_log_var')(x)
#
#     # VAE sampling function
#     def sampling(args):
#         z_mean, z_log_var = args
#         batch = K.shape(z_mean)[0]
#         dim = K.int_shape(z_mean)[1]
#         epsilon = K.random_normal(shape=(batch, dim))
#         return z_mean + K.exp(0.5 * z_log_var) * epsilon
#
#     z = Lambda(sampling, output_shape=(latent_dim,), name='z')([z_mean, z_log_var])
#     encoder = Model(encoder_inputs, [z_mean, z_log_var, z], name='encoder')
#
#     # VAE decoder
#     decoder_inputs = Input(shape=(latent_dim,))
#     x = Dense(8, activation='relu')(decoder_inputs)
#     x = Dense(16, activation='relu')(x)
#     decoder_outputs = Dense(input_dim, activation='sigmoid')(x) # Sigmoid for normalized features
#     decoder = Model(decoder_inputs, decoder_outputs, name='decoder')
#
#     # VAE model
#     outputs = decoder(encoder(encoder_inputs)[2])
#     vae = Model(encoder_inputs, outputs, name='vae')
#
#     # VAE loss function
#     reconstruction_loss = tf.keras.losses.mean_squared_error(encoder_inputs, outputs)
#     reconstruction_loss *= input_dim
#     kl_loss = 1 + z_log_var - K.square(z_mean) - K.exp(z_log_var)
#     kl_loss = K.sum(kl_loss, axis=-1)
#     kl_loss *= -0.5
#     vae_loss = K.mean(reconstruction_loss + kl_loss)
#     vae.add_loss(vae_loss)
#     vae.compile(optimizer='adam')
#     return vae, encoder, decoder
#
# def _train_vae_like_model(df_source):
#     """
#     Trains a VAE-like model on the feature distributions of historical draws.
#     """
#     global feature_means, feature_stds, feature_min_max, vae_features_columns, kmeans_model, scaler_model
#
#     if df_source.empty:
#         print("Cannot train VAE model: Historical data is empty.")
#         return
#
#     try:
#         print("Preparing data for VAE-like model training...")
#         feature_matrix = df_source.apply(_extract_features_for_draw, axis=1, result_type='expand')
#         feature_matrix.columns = vae_features_columns = [
#             'odd_count', 'even_count', 'white_ball_sum', 'group_a_count',
#             'consecutive_pairs_count', 'tens_apart_pairs_count', 'same_last_digit_count',
#             'repeating_digit_count', 'num_in_range_1_9', 'num_in_range_10s',
#             'num_in_range_20s', 'num_in_range_30s', 'num_in_range_40s',
#             'num_in_range_50s', 'num_in_range_60s', 'is_monday_draw',
#             'is_wednesday_draw', 'is_saturday_draw', 'powerball_value',
#             'is_single_pick_pattern', 'is_two_number_pick_pattern',
#             'is_three_number_pick_pattern', 'is_two_two_pick_pattern'
#         ]
#         feature_matrix = feature_matrix.dropna()
#
#         if feature_matrix.empty:
#             print("Feature matrix is empty. Cannot train VAE model.")
#             return
#
#         # Use a different scaler for the VAE model that maps to a 0-1 range
#         # We'll normalize each feature column to a 0-1 range
#         feature_means = feature_matrix.mean().values
#         feature_stds = feature_matrix.std().values
#         feature_min_max = [(feature_matrix[col].min(), feature_matrix[col].max()) for col in vae_features_columns]
#
#         # We'll normalize the data for the VAE training
#         normalized_features = (feature_matrix - feature_means) / feature_stds
#
#         # Now train a simple K-Means model on the normalized data to create "clusters"
#         # This is a fallback and not the core VAE approach, but a simple version of the requested functionality
#         kmeans_model = KMeans(n_clusters=8, random_state=42, n_init=10).fit(normalized_features)
#         scaler_model = StandardScaler().fit(feature_matrix)
#
#         print("VAE-like model training complete.")
#
#     except Exception as e:
#         print(f"Error during VAE-like model training: {e}")
#         traceback.print_exc()
#
#
# def _generate_vae_like_feature_vector():
#     """
#     Generates a synthetic feature vector by sampling from the learned distributions.
#     """
#     global feature_means, feature_stds, feature_min_max, vae_features_columns
#
#     if feature_means is None or feature_stds is None:
#         raise ValueError("Feature distributions not learned. VAE model not ready.")
#
#     synthetic_features = []
#     for i in range(len(feature_means)):
#         mean = feature_means[i]
#         std = feature_stds[i]
#         min_val, max_val = feature_min_max[i]
#         # Sample from a normal distribution. Clamp to observed min/max to prevent extreme values.
#         sampled_value = np.random.normal(loc=mean, scale=std)
#         sampled_value = np.clip(sampled_value, min_val, max_val) # Clamp to historical range
#
#         # Special handling for discrete/integer features
#         if vae_features_columns[i] in ['odd_count', 'even_count', 'group_a_count', 'consecutive_pairs_count',
#                                         'tens_apart_pairs_count', 'same_last_digit_count', 'repeating_digit_count',
#                                         'num_in_range_1_9', 'num_in_range_10s', 'num_in_range_20s', 'num_in_range_30s',
#                                         'num_in_range_40s', 'num_in_range_50s', 'num_in_range_60s',
#                                         'is_monday_draw', 'is_wednesday_draw', 'is_saturday_draw',
#                                         'is_single_pick_pattern', 'is_two_number_pick_pattern',
#                                         'is_three_number_pick_pattern', 'is_two_two_pick_pattern',
#                                         'is_one_two_three_pick_pattern', 'powerball_value']:
#             sampled_value = round(sampled_value)
#
#         synthetic_features.append(sampled_value)
#
#     return np.array(synthetic_features)
#
# def _generate_pick_from_features(target_features, current_draw_date_dt, excluded_numbers, max_attempts=5000):
#     """
#     Generates a pick that matches a target feature vector using brute-force random generation
#     and feature-based distance matching.
#     """
#     global scaler_model
#     if scaler_model is None:
#         print("Scaler model not available. Cannot generate pick from features.")
#         return None, None
#
#     best_pick_white_balls = None
#     best_pick_powerball = None
#     min_distance = float('inf')
#
#     available_white_balls_pool = [num for num in range(GLOBAL_WHITE_BALL_RANGE[0], GLOBAL_WHITE_BALL_RANGE[1] + 1)
#                                   if num not in excluded_numbers]
#
#     if len(available_white_balls_pool) < 5:
#         print(f"Not enough white balls in pool ({len(available_white_balls_pool)}) after exclusions for feature-based pick generation.")
#         return None, None
#
#     for attempt in range(max_attempts):
#         candidate_white_balls = sorted(random.sample(available_white_balls_pool, 5))
#         candidate_powerball = random.randint(GLOBAL_POWERBALL_RANGE[0], GLOBAL_POWERBALL_RANGE[1])
#
#         # Check for historical match
#         if check_exact_match(candidate_white_balls):
#             continue
#
#         # Extract features and scale them
#         candidate_features = _extract_features_for_candidate(
#             candidate_white_balls, candidate_powerball, current_draw_date_dt
#         )
#         if candidate_features is None:
#             continue
#
#         scaled_candidate_features = scaler_model.transform(np.array(candidate_features).reshape(1, -1))[0]
#
#         # Scale the target features using the same scaler
#         scaled_target_features = scaler_model.transform(np.array(target_features).reshape(1, -1))[0]
#
#         distance = np.linalg.norm(scaled_candidate_features - scaled_target_features)
#
#         if distance < min_distance:
#             min_distance = distance
#             best_pick_white_balls = candidate_white_balls
#             best_pick_powerball = candidate_powerball
#
#             if min_distance < 0.1: # Threshold for a good match
#                 break
#
#     return best_pick_white_balls, best_pick_powerball
#
#
# def initialize_ml_models():
#     """Initializes and trains the ML models."""
#     global df, kmeans_model, scaler_model
#     if not df.empty and kmeans_model is None:
#         try:
#             # First, prepare the data and scale it
#             feature_matrix = df.apply(_extract_features_for_draw, axis=1, result_type='expand')
#             feature_matrix = feature_matrix.dropna()
#
#             if feature_matrix.empty:
#                 print("Feature matrix is empty. Cannot train K-Means model.")
#                 return
#
#             scaler_model = StandardScaler().fit(feature_matrix)
#             scaled_features = scaler_model.transform(feature_matrix)
#
#             # Now train K-Means on the scaled data
#             kmeans_model = KMeans(n_clusters=8, random_state=42, n_init=10).fit(scaled_features)
#
#             print("ML models initialized and trained.")
#         except Exception as e:
#             print(f"Error during ML model initialization: {e}")
#             traceback.print_exc()

def initialize_core_data():
    """Initializes and loads all core data from Supabase and performs initial analyses."""
    global df, last_draw, historical_white_ball_sets, white_ball_co_occurrence_lookup, last_analysis_cache_update
    print("Initializing core data...")
    df = load_historical_data_from_supabase()

    if not df.empty:
        last_draw = get_last_draw(df)
        historical_white_ball_sets = {frozenset([int(row[f'Number {i}']) for i in range(1, 6)]) for _, row in df.iterrows()}
        white_ball_co_occurrence_lookup = {
            frozenset(sorted([int(row[f'Number {i}']) for i in range(1, 6)]) if pd.notna(row[f'Number 1']) else []):
            row['Draw Date_dt'].strftime('%Y-%m-%d')
            for _, row in df.iterrows()
        }
        # --- COMMENTED OUT ML/DL MODEL INITIALIZATION ---
        # initialize_ml_models()
        # _train_vae_like_model(df)

    last_analysis_cache_update = datetime.now()
    print("Core data initialization complete.")


def get_cached_analysis(cache_key, analysis_func, *args, **kwargs):
    """
    Retrieves cached analysis results or computes and caches them if stale.
    """
    global analysis_cache, last_analysis_cache_update
    current_time = datetime.now()
    if cache_key in analysis_cache and (current_time - last_analysis_cache_update) < CACHE_DURATION:
        print(f"Serving cached data for {cache_key}")
        return analysis_cache[cache_key]
    else:
        print(f"Re-computing and caching data for {cache_key}")
        result = analysis_func(*args, **kwargs)
        analysis_cache[cache_key] = result
        last_analysis_cache_update = current_time
        return result

def calculate_consecutive_gaps(df_source):
    """Calculates the gaps between consecutive numbers in historical draws."""
    # ... (function body remains) ...
    # ... (rest of the functions: frequency_analysis, hot_cold_numbers, find_last_draw_dates_for_numbers, etc. remain as they are) ...

# ... (all other utility functions that do not use ML/DL) ...


# --- Flask Routes ---

@app.route('/')
def index():
    fetch_data_from_supabase()
    last_draw_dict = last_draw.to_dict()
    return render_template('index.html', last_draw=last_draw_dict, sum_ranges=SUM_RANGES, selected_odd_even_choice="Any", selected_sum_range="Any", num_sets_to_generate=1)

@app.route('/generate', methods=['POST'])
def generate():
    # ... (function body remains) ...
    pass

@app.route('/generate_with_user_pair', methods=['POST'])
def generate_with_user_pair_route():
    # ... (function body remains) ...
    pass

@app.route('/analyze')
def analyze():
    fetch_data_from_supabase()
    return render_template('analyze.html', last_draw=last_draw.to_dict())

@app.route('/frequency_analysis')
def frequency_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/hot_cold_numbers')
def hot_cold_numbers_route():
    # ... (function body remains) ...
    pass

@app.route('/co_occurrence_analysis')
def co_occurrence_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/monthly_analysis')
def monthly_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/gap_analysis')
def gap_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/draw_days_analysis')
def draw_days_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/sum_analysis')
def sum_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/consecutive_number_analysis')
def consecutive_number_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/low_high_analysis')
def low_high_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/odd_even_analysis')
def odd_even_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/range_pattern_analysis')
def range_pattern_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/special_patterns_analysis')
def special_patterns_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/probability_calc')
def probability_calc_route():
    # ... (function body remains) ...
    pass

@app.route('/user_number_checker', methods=['GET', 'POST'])
def user_number_checker_route():
    # ... (function body remains) ...
    pass

@app.route('/search_by_numbers', methods=['GET', 'POST'])
def search_by_numbers_route():
    # ... (function body remains) ...
    pass

@app.route('/search_by_draw_date', methods=['GET', 'POST'])
def search_by_draw_date_route():
    # ... (function body remains) ...
    pass

@app.route('/find_results_by_first_white_ball', methods=['GET', 'POST'])
def find_results_by_first_white_ball():
    # ... (function body remains) ...
    pass

@app.route('/strict_positional_search', methods=['GET', 'POST'])
def strict_positional_search_route():
    # ... (function body remains) ...
    pass

@app.route('/manual_draw_entry', methods=['GET', 'POST'])
def manual_draw_entry():
    # ... (function body remains) ...
    pass

@app.route('/simulations', methods=['GET', 'POST'])
def simulations_route():
    # ... (function body remains) ...
    pass

@app.route('/combinations', methods=['GET', 'POST'])
def combinations_route():
    # ... (function body remains) ...
    pass

# --- API Endpoints ---
@app.route('/api/get_chart_data', methods=['GET'])
def api_get_chart_data():
    # ... (function body remains) ...
    pass

@app.route('/api/white_ball_gaps', methods=['GET'])
def api_white_ball_gaps():
    # ... (function body remains) ...
    pass

@app.route('/api/get_hot_cold_chart_data', methods=['GET'])
def api_get_hot_cold_chart_data():
    # ... (function body remains) ...
    pass

@app.route('/api/save_generated_numbers', methods=['POST'])
def save_generated_numbers_api():
    # ... (function body remains) ...
    pass

@app.route('/api/run_simulations', methods=['POST'])
def api_run_simulations():
    # ... (function body remains) ...
    pass

@app.route('/api/run_simulations_by_sum', methods=['POST'])
def api_run_simulations_by_sum():
    # ... (function body remains) ...
    pass

@app.route('/api/generate_quick_pick', methods=['POST'])
def generate_quick_pick_api():
    # ... (function body remains) ...
    pass

# --- COMMENTED OUT ML/DL API ENDPOINTS ---
# @app.route('/api/generate_ml_smart_picks', methods=['POST'])
# def generate_ml_smart_picks_api():
#     """
#     Generates Powerball picks based on a chosen ML cluster.
#     """
#     # ... (original function body) ...
#     pass
#
# @app.route('/api/generate_vae_picks', methods=['POST'])
# def generate_vae_picks_api():
#     """
#     Generates Powerball picks using a VAE-like approach by sampling from learned feature distributions.
#     """
#     # ... (original function body) ...
#     pass

@app.route('/api/create_combinations', methods=['POST'])
def create_combinations_api():
    # ... (function body remains) ...
    pass

# Initialize core data on app startup
initialize_core_data()
