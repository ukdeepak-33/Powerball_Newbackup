import pandas as pd
from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
import random
from itertools import combinations
import math
import os
from collections import defaultdict
from datetime import datetime, timedelta
import requests
import json
import numpy as np
import traceback
import warnings

warnings.filterwarnings('ignore', category=UserWarning, module='sklearn') # Ignore specific KMeans warning

# --- Supabase Configuration ---
SUPABASE_PROJECT_URL = os.environ.get("SUPABASE_URL", "https://yksxzbbcoitehdmsxqex.supabase.co")
SUPABASE_ANON_KEY = os.environ.get("SUPABASE_ANON_KEY", "YOUR_ACTUAL_SUPABASE_ANON_KEY_GOES_HERE")
SUPABASE_SERVICE_KEY = os.environ.get("SUPABASE_SERVICE_KEY", "YOUR_ACTUAL_SUPABASE_SERVICE_ROLE_KEY_GOES_HERE")

SUPABASE_TABLE_NAME = 'powerball_draws'
GENERATED_NUMBERS_TABLE_NAME = 'generated_powerball_numbers'

# --- Flask App Initialization with Template Path ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
TEMPLATE_DIR = os.path.join(BASE_DIR, '..', 'templates')

app = Flask(__name__, template_folder=TEMPLATE_DIR)
app.secret_key = 'supersecretkey'

# --- Global Data and Cache ---
df = pd.DataFrame()
last_draw = pd.Series(dtype='object')

historical_white_ball_sets = set()
white_ball_co_occurrence_lookup = {}

analysis_cache = {}
last_analysis_cache_update = datetime.min

CACHE_DURATION = timedelta(minutes=60) # Cache for 60 minutes
CACHE_EXPIRATION_SECONDS = CACHE_DURATION.total_seconds()

# Data points used in analysis and smart pick generation
group_a = [3, 5, 6, 7, 9, 11, 15, 16, 18, 21, 23, 24, 27, 31, 32, 33, 36, 42, 44, 45, 48, 50, 51, 54, 55, 60, 66, 69]
GLOBAL_WHITE_BALL_RANGE = (1, 69)
GLOBAL_POWERBALL_RANGE = (1, 26)

NUMBER_RANGES = {
    "1-9": (1, 9),
    "10s": (10, 19),
    "20s": (20, 29),
    "30s": (30, 39),
    "40s": (40, 49),
    "50s": (50, 59),
    "60s": (60, 69)
}

ASCENDING_GEN_RANGES = [
    (10, 19),
    (20, 29),
    (30, 39),
    (40, 49),
    (50, 59),
    (60, 69)
]

SUM_RANGES = {
    "Any": None,
    "Zone A (60-99)": (60, 99),
    "Zone B (100-129)": (100, 129),
    "Zone C (130-159)": (130, 159),
    "Zone D (160-189)": (160, 189),
    "Zone E (190-220)": (190, 220),
    "Zone F (221-249)": (221, 249),
    "Zone G (250-300)": (250, 300)
}

LOW_NUMBER_MAX = 34
HIGH_NUMBER_MIN = 35

POWERBALL_DRAW_DAYS = ['Monday', 'Wednesday', 'Saturday']

BOUNDARY_PAIRS_TO_ANALYZE = [
    (9, 10), (19, 20), (29, 30), (39, 40), (49, 50), (59, 60)
]

# NEW: Define the types of range-based patterns observed by the user
RANGE_PATTERN_TYPES = [
    "Single Pick (1-1-1-1-1)",
    "Two-Number Pick (2-1-1-1)",
    "Three-Number Pick (3-1-1)",
    "Two-Two-Number Pick (2-2-1)",
    "One-Two-Three Number Pick (1-2-3)"
]

# NEW Global Variable for recent odd/even ratios
recent_odd_even_ratios = [] # To store the last few odd/even splits

def _get_ball_ranges_counts(white_balls):
    """
    Counts how many white balls fall into each predefined NUMBER_RANGES decade.
    Returns a dictionary like {'1-9': 2, '10s': 1, '20s': 0, ...}
    """
    range_counts = defaultdict(int)
    for num in white_balls:
        for range_name, (min_val, max_val) in NUMBER_RANGES.items():
            if min_val <= num <= max_val:
                range_counts[range_name] += 1
                break
    return range_counts

def _classify_range_pattern(white_balls):
    """
    Classifies the pattern of white balls based on their distribution across predefined ranges.
    """
    range_counts = defaultdict(int)
    for num in white_balls:
        for range_name, (min_val, max_val) in NUMBER_RANGES.items():
            if min_val <= num <= max_val:
                range_counts[range_name] += 1
                break

    active_range_ball_counts = sorted([count for count in range_counts.values() if count > 0], reverse=True)

    if active_range_ball_counts == [1, 1, 1, 1, 1]:
        return "Single Pick (1-1-1-1-1)"
    if active_range_ball_counts == [2, 1, 1, 1]:
        return "Two-Number Pick (2-1-1-1)"
    if active_range_ball_counts == [3, 1, 1]:
        return "Three-Number Pick (3-1-1)"
    if active_range_ball_counts == [2, 2, 1]:
        return "Two-Two-Number Pick (2-2-1)"
    if active_range_ball_counts == [3, 2, 1]:
        return "One-Two-Three Number Pick (1-2-3)"

    return "Other"

# --- Gemini API Configuration ---
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "")

# --- Core Utility Functions ---

def _get_supabase_headers(is_service_key=False):
    key = SUPABASE_SERVICE_KEY if is_service_key else SUPABASE_ANON_KEY
    return {
        "apikey": key,
        "Authorization": f"Bearer {key}",
        "Content-Type": "application/json"
    }

def load_historical_data_from_supabase():
    """Fetches historical Powerball draw data from Supabase."""
    all_data = []
    offset = 0
    limit = 1000

    try:
        url = f"{SUPABASE_PROJECT_URL}/rest/v1/{SUPABASE_TABLE_NAME}"
        headers = _get_supabase_headers(is_service_key=False)

        while True:
            params = {
                'select': '*',
                'order': 'Draw Date.asc',
                'offset': offset,
                'limit': limit
            }
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()

            chunk = response.json()
            if not chunk:
                break
            all_data.extend(chunk)
            offset += limit

        if not all_data:
            print("No data fetched from Supabase after pagination attempts.")
            return pd.DataFrame()

        df_loaded = pd.DataFrame(all_data)
        df_loaded['Draw Date_dt'] = pd.to_datetime(df_loaded['Draw Date'], errors='coerce')
        df_loaded = df_loaded.dropna(subset=['Draw Date_dt'])

        numeric_cols = ['Number 1', 'Number 2', 'Number 3', 'Number 4', 'Number 5', 'Powerball']
        for col in numeric_cols:
            if col in df_loaded.columns:
                df_loaded[col] = pd.to_numeric(df_loaded[col], errors='coerce')
                df_loaded[col] = df_loaded[col].fillna(0).astype(int)
            else:
                print(f"Warning: Column '{col}' not found in fetched data. Skipping conversion for this column.")

        df_loaded['Draw Date'] = df_loaded['Draw Date_dt'].dt.strftime('%Y-%m-%d')

        print(f"Successfully loaded and processed {len(df_loaded)} records from Supabase.")
        return df_loaded

    except requests.exceptions.RequestException as e:
        print(f"Error during Supabase data fetch request: {e}")
        if hasattr(e, 'response') and e.response is not None:
            print(f"Supabase response content: {e.response.text}")
        return pd.DataFrame()
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON response from Supabase: {e}")
        if 'response' in locals() and response is not None:
            print(f"Response content that failed JSON decode: {response.text}")
        return pd.DataFrame()
    except Exception as e:
        print(f"An unexpected error occurred in load_historical_data_from_supabase: {e}")
        return pd.DataFrame()

def get_last_draw(df_source):
    """Retrieves the most recent draw from the DataFrame."""
    if df_source.empty:
        return pd.Series({
            'Draw Date': 'N/A', 'Number 1': 'N/A', 'Number 2': 'N/A',
            'Number 3': 'N/A', 'Number 4': 'N/A', 'Number 5': 'N/A', 'Powerball': 'N/A',
            'Numbers': ['N/A', 'N/A', 'N/A', 'N/A', 'N/A']
        }, dtype='object')

    last_row = df_source.iloc[-1].copy()

    if 'Number 1' in last_row and pd.notna(last_row['Number 1']):
        last_row['Numbers'] = [
            int(last_row['Number 1']), int(last_row['Number 2']), int(last_row['Number 3']),
            int(last_row['Number 4']), int(last_row['Number 5'])
        ]
    else:
        last_row['Numbers'] = ['N/A'] * 5

    if 'Draw Date_dt' in last_row and pd.notna(last_row['Draw Date_dt']):
        last_row['Draw Date'] = last_row['Draw Date_dt'].strftime('%Y-%m-%d')
    elif 'Draw Date' not in last_row:
        last_row['Draw Date'] = 'N/A'

    return last_row

def check_exact_match(white_balls):
    """Checks if a given set of white balls exactly matches any historical draw."""
    global historical_white_ball_sets
    return frozenset(white_balls) in historical_white_ball_sets

def generate_powerball_numbers(df_source, group_a_list, odd_even_choice, combo_choice, white_ball_range, powerball_range, excluded_numbers, high_low_balance=None, selected_sum_range_tuple=None, is_simulation=False):
    """Generates a single Powerball combination based on various criteria."""
    if df_source.empty:
        raise ValueError("Cannot generate numbers: Historical data is empty.")

    max_attempts = 5000
    attempts = 0

    base_available_white_balls = [num for num in range(white_ball_range[0], white_ball_range[1] + 1) if num not in excluded_numbers]
    if len(base_available_white_balls) < 5:
        raise ValueError("Not enough available white balls after exclusions and range constraints.")

    while attempts < max_attempts:

        white_balls_candidate = sorted(random.sample(base_available_white_balls, 5))

        even_count = sum(1 for num in white_balls_candidate if num % 2 == 0)
        odd_count = 5 - even_count

        if odd_even_choice == "All Even" and even_count != 5:
            attempts += 1
            continue
        elif odd_even_choice == "All Odd" and odd_count != 5:
            attempts += 1
            continue
        elif odd_even_choice == "3 Even / 2 Odd" and (even_count != 3 or odd_count != 2):
            attempts += 1
            continue
        elif odd_even_choice == "2 Even / 3 Odd" and (even_count != 2 or odd_count != 3):
            attempts += 1
            continue
        elif odd_even_choice == "1 Even / 4 Odd" and (even_count != 1 or odd_count != 4):
            attempts += 1
            continue
        elif odd_even_choice == "4 Even / 1 Odd" and (even_count != 4 or odd_count != 1):
            attempts += 1
            continue

        if selected_sum_range_tuple:
            current_sum = sum(white_balls_candidate)
            if not (selected_sum_range_tuple[0] <= current_sum <= selected_sum_range_tuple[1]):
                attempts += 1
                continue

        group_a_numbers = [num for num in white_balls_candidate if num in group_a_list]
        if len(group_a_numbers) < 2:
            attempts += 1
            continue

        if high_low_balance is not None:
            low_numbers_count = sum(1 for num in white_balls_candidate if num <= LOW_NUMBER_MAX)
            high_numbers_count = sum(1 for num in white_balls_candidate if num >= HIGH_NUMBER_MIN)
            if low_numbers_count != high_low_balance[0] or high_numbers_count != high_low_balance[1]:
                attempts += 1
                continue

        if not is_simulation:
            last_draw_data = get_last_draw(df_source)
            if not last_draw_data.empty and last_draw_data.get('Draw Date') != 'N/A':
                last_white_balls = [int(last_draw_data['Number 1']), int(last_draw_data['Number 2']), int(last_draw_data['Number 3']), int(last_draw_data['Number 4']), int(last_draw_data['Number 5'])]
                if set(white_balls_candidate) == set(last_white_balls):
                    attempts += 1
                    continue

            if check_exact_match(white_balls_candidate):
                attempts += 1
                continue

        powerball = random.randint(powerball_range[0], powerball_range[1])
        return white_balls_candidate, powerball

    raise ValueError("Could not generate a unique combination meeting all criteria after many attempts. Try adjusting filters or increasing max_attempts.")


def generate_from_group_a(df_source, num_from_group_a, white_ball_range, powerball_range, excluded_numbers, selected_sum_range_tuple=None):
    """Generates a Powerball combination ensuring a certain number of Group A numbers."""
    if df_source.empty:
        raise ValueError("Cannot generate numbers: Historical data is empty.")

    max_attempts = 2000
    attempts = 0

    valid_group_a = [num for num in group_a if white_ball_range[0] <= num <= white_ball_range[1] and num not in excluded_numbers]

    remaining_pool = [num for num in range(white_ball_range[0], white_ball_range[1] + 1)
                      if num not in valid_group_a and num not in excluded_numbers]

    if len(valid_group_a) < num_from_group_a:
        raise ValueError(f"Not enough unique numbers in Group A ({len(valid_group_a)}) to pick {num_from_group_a}.")

    num_from_remaining = 5 - num_from_group_a
    if len(remaining_pool) < num_from_remaining:
        raise ValueError(f"Not enough unique numbers in the remaining pool ({len(remaining_pool)}) to pick {num_from_remaining}.")

    while attempts < max_attempts:
        try:
            selected_from_group_a = random.sample(valid_group_a, num_from_group_a)

            available_for_remaining = [num for num in remaining_pool if num not in selected_from_group_a]
            if len(available_for_remaining) < num_from_remaining:
                attempts += 1
                continue
            selected_from_remaining = random.sample(available_for_remaining, num_from_remaining)
            white_balls = sorted(selected_from_group_a + selected_from_remaining)
            if selected_sum_range_tuple:
                current_sum = sum(white_balls)
                if not (selected_sum_range_tuple[0] <= current_sum <= selected_sum_range_tuple[1]):
                    attempts += 1
                    continue
            powerball = random.randint(powerball_range[0], powerball[1])
            if check_exact_match(white_balls):
                attempts += 1
                continue
            break
        except ValueError as e:
            attempts += 1
            continue
        except IndexError:
            attempts += 1
            continue
    else:
        raise ValueError("Could not generate a unique combination with Group A strategy meeting all criteria after many attempts. Try adjusting filters.")
    return white_balls, powerball

def generate_with_user_provided_pair(num1, num2, white_ball_range, powerball_range, excluded_numbers, df_source, selected_sum_range_tuple=None):
    """Generates a Powerball combination starting with two user-provided white balls."""
    if df_source.empty:
        raise ValueError("Cannot generate with provided pair: Historical data is empty.")

    if not (white_ball_range[0] <= num1 <= white_ball_range[1] and
            white_ball_range[0] <= num2 <= white_ball_range[1]):
        raise ValueError(f"Provided numbers ({num1}, {num2}) must be within the white ball range ({white_ball_range[0]}-{white_ball_range[1]}).")

    if num1 == num2:
        raise ValueError("The two provided white balls must be unique.")

    if num1 in excluded_numbers or num2 in excluded_numbers:
        raise ValueError(f"One or both provided numbers ({num1}, {num2}) are in the excluded list.")

    initial_white_balls = sorted([num1, num2])

    max_attempts_overall = 2000
    attempts_overall = 0

    while attempts_overall < max_attempts_overall:
        candidate_white_balls_generated = []
        temp_current_min = initial_white_balls[-1] + 1

        try:
            for i in range(3):
                possible_nums_for_slot = []

                start_range_idx = -1
                for idx, (range_min, range_max) in enumerate(ASCENDING_GEN_RANGES):
                    if temp_current_min <= range_max and temp_current_min >= range_min:
                        start_range_idx = idx
                        break
                    elif temp_current_min < range_min:
                        start_range_idx = idx
                        break

                if start_range_idx == -1:
                    raise ValueError("Not enough space in ascending ranges to complete combination.")

                eligible_ranges = ASCENDING_GEN_RANGES[start_range_idx:]

                for range_min, range_max in eligible_ranges:
                    actual_start_val = max(temp_current_min, range_min)

                    for num in range(actual_start_val, range_max + 1):
                        if num not in excluded_numbers and \
                           num not in initial_white_balls and \
                           num not in candidate_white_balls_generated:
                            possible_nums_for_slot.append(num)

                if not possible_nums_for_slot:
                    raise ValueError(f"No available numbers for slot {i+3}. Current min: {temp_current_min}, initial: {initial_white_balls}, generated: {candidate_white_balls_generated}")

                picked_num = random.choice(possible_nums_for_slot)
                candidate_white_balls_generated.append(picked_num)
                temp_current_min = picked_num + 1

            final_white_balls = sorted(initial_white_balls + candidate_white_balls_generated)

            if selected_sum_range_tuple:
                current_sum = sum(final_white_balls)
                if not (selected_sum_range_tuple[0] <= current_sum <= selected_sum_range_tuple[1]):
                    attempts_overall += 1
                    continue

            powerball = random.randint(powerball_range[0], powerball_range[1])

            if check_exact_match(final_white_balls):
                attempts_overall += 1
                continue

            last_draw_data = get_last_draw(df_source)
            if not last_draw_data.empty and last_draw_data.get('Draw Date') != 'N/A':
                last_white_balls = [int(last_draw_data['Number 1']), int(last_draw_data['Number 2']), int(last_draw_data['Number 3']), int(last_draw_data['Number 4']), int(last_draw_data['Number 5'])]
                if set(final_white_balls) == set(last_white_balls) and powerball == int(last_draw_data['Powerball']):
                    attempts_overall += 1
                    continue

            return final_white_balls, powerball

        except ValueError as e:
            attempts_overall += 1
            continue
        except IndexError:
            attempts_overall += 1
            continue
    else:
        raise ValueError("Could not generate a unique combination with the provided pair and ascending range constraint meeting all criteria after many attempts. Try adjusting filters.")

def _extract_features_for_candidate(white_balls, powerball, draw_date_dt):
    """
    Extracts a numerical feature vector from a candidate Powerball pick
    (list of white balls, powerball, and a datetime object for the draw date).
    Used for evaluating candidate picks against historical trends.
    """
    if not isinstance(white_balls, list) or len(white_balls) != 5:
        return None
    if not isinstance(powerball, int) or not (GLOBAL_POWERBALL_RANGE[0] <= powerball <= GLOBAL_POWERBALL_RANGE[1]):
        return None
    if not isinstance(draw_date_dt, datetime):
        draw_date_dt = datetime.now()

    if not all(GLOBAL_WHITE_BALL_RANGE[0] <= num <= GLOBAL_WHITE_BALL_RANGE[1] for num in white_balls):
        return None
    if len(set(white_balls)) != 5:
        return None

    sorted_white_balls = sorted(white_balls)

    odd_count = sum(1 for num in sorted_white_balls if num % 2 != 0)
    even_count = 5 - odd_count
    white_ball_sum = sum(sorted_white_balls)
    group_a_count = sum(1 for num in sorted_white_balls if num in group_a)

    consecutive_pairs_count = 0
    for i in range(len(sorted_white_balls) - 1):
        if sorted_white_balls[i] + 1 == sorted_white_balls[i+1]:
            consecutive_pairs_count += 1

    tens_apart_pairs_count = 0
    for i in range(len(sorted_white_balls)):
        for j in range(i + 1, len(sorted_white_balls)):
            diff = abs(sorted_white_balls[i] - sorted_white_balls[j])
            if diff in [10, 20, 30, 40, 50]:
                tens_apart_pairs_count += 1

    last_digit_counts = defaultdict(int)
    for num in sorted_white_balls:
        last_digit_counts[num % 10] += 1
    same_last_digit_count = sum(count for count in last_digit_counts.values() if count >= 2)

    repeating_digit_numbers = [11, 22, 33, 44, 55, 66]
    repeating_digit_count = sum(1 for num in sorted_white_balls if num in repeating_digit_numbers)

    num_in_range = defaultdict(int)
    for num in sorted_white_balls:
        if 1 <= num <= 9: num_in_range['1-9'] += 1
        elif 10 <= num <= 19: num_in_range['10s'] += 1
        elif 20 <= num <= 29: num_in_range['20s'] += 1
        elif 30 <= num <= 39: num_in_range['30s'] += 1
        elif 40 <= num <= 49: num_in_range['40s'] += 1
        elif 50 <= num <= 59: num_in_range['50s'] += 1
        elif 60 <= num <= 69: num_in_range['60s'] += 1

    draw_weekday = draw_date_dt.day_name()
    is_monday_draw = 1 if draw_weekday == 'Monday' else 0
    is_wednesday_draw = 1 if draw_weekday == 'Wednesday' else 0
    is_saturday_draw = 1 if draw_weekday == 'Saturday' else 0

    powerball_value = powerball

    current_range_pattern_type = _classify_range_pattern(white_balls)
    is_single_pick_pattern = 1 if current_range_pattern_type == "Single Pick (1-1-1-1-1)" else 0
    is_two_number_pick_pattern = 1 if current_range_pattern_type == "Two-Number Pick (2-1-1-1)" else 0
    is_three_number_pick_pattern = 1 if current_range_pattern_type == "Three-Number Pick (3-1-1)" else 0
    is_two_two_pick_pattern = 1 if current_range_pattern_type == "Two-Two-Number Pick (2-2-1)" else 0
    is_one_two_three_pick_pattern = 1 if current_range_pattern_type == "One-Two-Three Number Pick (1-2-3)" else 0

    features = {
        'odd_count': odd_count,
        'even_count': even_count,
        'white_ball_sum': white_ball_sum,
        'group_a_count': group_a_count,
        'consecutive_pairs_count': consecutive_pairs_count,
        'tens_apart_pairs_count': tens_apart_pairs_count,
        'same_last_digit_count': same_last_digit_count,
        'repeating_digit_count': repeating_digit_count,
        'num_in_range_1_9': num_in_range['1-9'],
        'num_in_range_10s': num_in_range['10s'],
        'num_in_range_20s': num_in_range['20s'],
        'num_in_range_30s': num_in_range['30s'],
        'num_in_range_40s': num_in_range['40s'],
        'num_in_range_50s': num_in_range['50s'],
        'num_in_range_60s': num_in_range['60s'],
        'is_monday_draw': is_monday_draw,
        'is_wednesday_draw': is_wednesday_draw,
        'is_saturday_draw': is_saturday_draw,
        'powerball_value': powerball_value,
        'is_single_pick_pattern': is_single_pick_pattern,
        'is_two_number_pick_pattern': is_two_number_pick_pattern,
        'is_three_number_pick_pattern': is_three_number_pick_pattern,
        'is_two_two_pick_pattern': is_two_two_pick_pattern,
        'is_one_two_three_pick_pattern': is_one_two_three_pick_pattern
    }
    return features

def _generate_smart_pick(num_sets_to_generate, excluded_numbers):
    """
    Generates a smart pick based on a set of historically common, rule-based criteria.
    This replaces the ML/DL smart pick generation.
    """
    generated_sets = []
    last_draw_dates = {}
    last_5_white_ball_sets = []
    if not df.empty:
        for _, row in df.tail(5).iterrows():
            last_5_white_ball_sets.append(frozenset([
                int(row['Number 1']), int(row['Number 2']), int(row['Number 3']),
                int(row['Number 4']), int(row['Number 5'])
            ]))

    max_attempts_per_set = 5000
    for _ in range(num_sets_to_generate):
        attempts = 0
        found_pick = False
        while attempts < max_attempts_per_set and not found_pick:
            white_balls_candidate = sorted(random.sample(
                [num for num in range(GLOBAL_WHITE_BALL_RANGE[0], GLOBAL_WHITE_BALL_RANGE[1] + 1) if num not in excluded_numbers], 5
            ))
            powerball_candidate = random.randint(GLOBAL_POWERBALL_RANGE[0], GLOBAL_POWERBALL_RANGE[1])
            
            # Check for immediate repeats or historical exact matches
            if frozenset(white_balls_candidate) in historical_white_ball_sets or \
               frozenset(white_balls_candidate) in last_5_white_ball_sets:
                attempts += 1
                continue

            # Extract features for rule-based evaluation
            features = _extract_features_for_candidate(white_balls_candidate, powerball_candidate, datetime.now())
            if features is None:
                attempts += 1
                continue

            # Apply "smart" rules based on historical trends
            # Rule 1: Sum should be in a common range (e.g., 130-159 or 160-189)
            if not (SUM_RANGES["Zone C (130-159)"][0] <= features['white_ball_sum'] <= SUM_RANGES["Zone C (130-159)"][1] or \
                    SUM_RANGES["Zone D (160-189)"][0] <= features['white_ball_sum'] <= SUM_RANGES["Zone D (160-189)"][1]):
                attempts += 1
                continue
            
            # Rule 2: Odd/Even split should be balanced
            if features['odd_count'] not in [2, 3] or features['even_count'] not in [2, 3]:
                attempts += 1
                continue

            # Rule 3: Must contain at least two numbers from Group A
            if features['group_a_count'] < 2:
                attempts += 1
                continue
            
            # Rule 4: No more than one consecutive pair (historically common)
            if features['consecutive_pairs_count'] > 1:
                attempts += 1
                continue

            # If all rules pass, this is our smart pick
            generated_sets.append({'white_balls': white_balls_candidate, 'powerball': powerball_candidate})
            last_draw_dates = find_last_draw_dates_for_numbers(df, white_balls_candidate, powerball_candidate)
            found_pick = True

        if not found_pick:
             print(f"Warning: Failed to generate a valid smart pick after many attempts.")

    if not generated_sets:
        raise ValueError("Could not generate any smart picks after multiple attempts. Try adjusting excluded numbers.")

    return generated_sets, last_draw_dates, "Generated based on historically common statistical rules."


def initialize_core_data():
    """Initializes and loads all core data from Supabase and performs initial analyses."""
    global df, last_draw, historical_white_ball_sets, white_ball_co_occurrence_lookup, last_analysis_cache_update
    print("Initializing core data...")
    df = load_historical_data_from_supabase()

    if not df.empty:
        last_draw = get_last_draw(df)
        historical_white_ball_sets = {frozenset([int(row[f'Number {i}']) for i in range(1, 6)]) for _, row in df.iterrows()}
        white_ball_co_occurrence_lookup = {
            frozenset(sorted([int(row[f'Number {i}']) for i in range(1, 6)]) if pd.notna(row[f'Number 1']) else []):
            row['Draw Date_dt'].strftime('%Y-%m-%d')
            for _, row in df.iterrows()
        }

    last_analysis_cache_update = datetime.now()
    print("Core data initialization complete.")


def get_cached_analysis(cache_key, analysis_func, *args, **kwargs):
    """
    Retrieves cached analysis results or computes and caches them if stale.
    """
    global analysis_cache, last_analysis_cache_update
    current_time = datetime.now()
    if cache_key in analysis_cache and (current_time - last_analysis_cache_update) < CACHE_DURATION:
        print(f"Serving cached data for {cache_key}")
        return analysis_cache[cache_key]
    else:
        print(f"Re-computing and caching data for {cache_key}")
        result = analysis_func(*args, **kwargs)
        analysis_cache[cache_key] = result
        last_analysis_cache_update = current_time
        return result

# --- All other analysis and generation functions remain unchanged ---
def calculate_consecutive_gaps(df_source):
    # ... (body unchanged) ...
    pass
# ... (all other utility functions that do not use ML/DL) ...

# --- Flask Routes ---

@app.route('/')
def index():
    fetch_data_from_supabase()
    last_draw_dict = last_draw.to_dict()
    return render_template('index.html', last_draw=last_draw_dict, sum_ranges=SUM_RANGES, selected_odd_even_choice="Any", selected_sum_range="Any", num_sets_to_generate=1)

@app.route('/generate', methods=['POST'])
def generate():
    # ... (function body remains) ...
    pass

@app.route('/generate_with_user_pair', methods=['POST'])
def generate_with_user_pair_route():
    # ... (function body remains) ...
    pass

@app.route('/analyze')
def analyze():
    fetch_data_from_supabase()
    return render_template('analyze.html', last_draw=last_draw.to_dict())

@app.route('/frequency_analysis')
def frequency_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/hot_cold_numbers')
def hot_cold_numbers_route():
    # ... (function body remains) ...
    pass

@app.route('/co_occurrence_analysis')
def co_occurrence_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/monthly_analysis')
def monthly_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/gap_analysis')
def gap_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/draw_days_analysis')
def draw_days_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/sum_analysis')
def sum_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/consecutive_number_analysis')
def consecutive_number_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/low_high_analysis')
def low_high_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/odd_even_analysis')
def odd_even_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/range_pattern_analysis')
def range_pattern_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/special_patterns_analysis')
def special_patterns_analysis_route():
    # ... (function body remains) ...
    pass

@app.route('/probability_calc')
def probability_calc_route():
    # ... (function body remains) ...
    pass

@app.route('/user_number_checker', methods=['GET', 'POST'])
def user_number_checker_route():
    # ... (function body remains) ...
    pass

@app.route('/search_by_numbers', methods=['GET', 'POST'])
def search_by_numbers_route():
    # ... (function body remains) ...
    pass

@app.route('/search_by_draw_date', methods=['GET', 'POST'])
def search_by_draw_date_route():
    # ... (function body remains) ...
    pass

@app.route('/find_results_by_first_white_ball', methods=['GET', 'POST'])
def find_results_by_first_white_ball():
    # ... (function body remains) ...
    pass

@app.route('/strict_positional_search', methods=['GET', 'POST'])
def strict_positional_search_route():
    # ... (function body remains) ...
    pass

@app.route('/manual_draw_entry', methods=['GET', 'POST'])
def manual_draw_entry():
    # ... (function body remains) ...
    pass

@app.route('/simulations', methods=['GET', 'POST'])
def simulations_route():
    # ... (function body remains) ...
    pass

@app.route('/combinations', methods=['GET', 'POST'])
def combinations_route():
    # ... (function body remains) ...
    pass

# --- API Endpoints ---
@app.route('/api/get_chart_data', methods=['GET'])
def api_get_chart_data():
    # ... (function body remains) ...
    pass

@app.route('/api/white_ball_gaps', methods=['GET'])
def api_white_ball_gaps():
    # ... (function body remains) ...
    pass

@app.route('/api/get_hot_cold_chart_data', methods=['GET'])
def api_get_hot_cold_chart_data():
    # ... (function body remains) ...
    pass

@app.route('/api/save_generated_numbers', methods=['POST'])
def save_generated_numbers_api():
    # ... (function body remains) ...
    pass

@app.route('/api/run_simulations', methods=['POST'])
def api_run_simulations():
    # ... (function body remains) ...
    pass

@app.route('/api/run_simulations_by_sum', methods=['POST'])
def api_run_simulations_by_sum():
    # ... (function body remains) ...
    pass

@app.route('/api/generate_quick_pick', methods=['POST'])
def generate_quick_pick_api():
    # ... (function body remains) ...
    pass

@app.route('/api/generate_smart_picks', methods=['POST'])
def generate_smart_picks_api():
    """
    Generates Powerball picks based on a set of historically common, rule-based criteria.
    This replaces the ML/DL smart pick generation.
    """
    try:
        data = request.get_json()
        num_sets_to_generate = int(data.get('numSetsToGenerate', 1))
        excluded_numbers_str = data.get('excludedNumbers', '')
        excluded_numbers = [int(n.strip()) for n in excluded_numbers_str.split(',') if n.strip().isdigit()]

        generated_sets, last_draw_dates, ml_cluster_info = _generate_smart_pick(num_sets_to_generate, excluded_numbers)

        return jsonify({
            'success': True,
            'generated_sets': generated_sets,
            'last_draw_dates': last_draw_dates,
            'ml_cluster_info': ml_cluster_info
        })

    except ValueError as e:
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': f"An unexpected error occurred: {e}"}), 500


@app.route('/api/create_combinations', methods=['POST'])
def create_combinations_api():
    # ... (function body remains) ...
    pass

# Initialize core data on app startup
initialize_core_data()
